#!/usr/bin/env bash
#
# Summary: Update packages in all or paticular pyenv environments
#
# Usage: pyenv pip-upgrade [OPTIONS] <pyenv_env1> [<pyenv_env2> ...]
#        pyenv pip-upgrade [OPTIONS] --all
#
# This command update all packages to the latest versions of particular or all 
# pyenv environments excluding system. By default, pip-upgrade update all 
# outdated packages of an environment at once. New pip versions will generate an 
# error if the environment contains packages with conflicting dependencies. In 
# this case, you can add option '--sequential' to update packages sequentially, 
# however, the lately updated package will have precedence in this case 
# overriding the dependencies of the packages updated before.  
# 
# ARGUMENTS: 
#   --all - to update all environments
# 
# OPTIONS:
#   --sequential - update all outdated packages one by one

# setting bash strict mode
set -o errexit 
set -o pipefail
set -o nounset
IFS=$'\n\t'

# enabling debugging if pyenv in debug mode
[[ -n ${PYENV_DEBUG:-} ]] && set -x

# functions
function __msg_error () {
  printf '\e[1;31m[ERROR]: %s\n\e[0m' "${1}" >&2
}

function __msg_info () {
  printf '\e[1;33m[INFO]: %s\n\e[0m' "${1}"
}

function elementIn () {
  local elem="$1"   # Save first argument in a variable
  shift            # Shift all arguments to the left (original $1 gets lost)
  local arr=("$@") # Rebuild the array with rest of arguments
  if printf '%s\n' "${arr[@]}" | grep -q --line-regexp "${elem}"; then
    return 0
  fi
  return 1
}

function pip_upgrade_packages () {
  # https://stackoverflow.com/a/3452888/1108213
  local outdated_packages=()
  while IFS='' read -r line; do 
    outdated_packages+=("$line"); 
  done < <(pip list --outdated --format=freeze 2>/dev/null | grep -v '^\-e' | cut -d = -f 1)
  if [[ ${#outdated_packages[@]} -eq 0 ]]; then
    __msg_info "Nothing to update in this environment..."
    return
  fi
  if [[ "$strategy" == "serial" ]]; then
    __msg_info "Updating packages: $(IFS=$' '; echo "${outdated_packages[*]}")"
    pip install --upgrade "${outdated_packages[@]}"
  elif [[ "$strategy" == "sequential" ]]; then
    for pck in "${outdated_packages[@]}"; do
      __msg_info "Updating package $pck..."
      pip install --upgrade "$pck"
    done
  fi
}


# --bare - allows to skip system installation
# --skip-aliases - skips environment aliases (speeding up updates by skipping aliases)
pyenvs=()
while IFS='' read -r line; do 
  pyenvs+=("$line"); 
done < <(pyenv versions --bare --skip-aliases)

# Provide pyenv completions
if [ "$1" = "--complete" ]; then
  echo "--all" # add '--all' as completion option
  echo "--sequential"
  echo "${pyenvs[@]}"
  exit
fi

all_envs=false
pyenvs_to_update=()
invalid_args=()
strategy="serial"

while [[ $# -gt 0 ]]; do
  argument="$1"
  case $argument in 
    --all)
      all_envs=true
      shift
      ;;
    --sequential)
      strategy="${argument:2}"
      shift
      ;;
    *) # unknown option - assume that this is pyenv environment name
      # check if argument is among pyenv versions
      # if printf '%s\n' "${pyenvs[@]}" | grep -q --line-regexp "${argument}"; then
      if elementIn "${argument}" "${pyenvs[@]}"; then
        pyenvs_to_update+=( "$argument" )
      else
        invalid_args+=( "$argument" )
      fi
      shift # past argument
      ;;
  esac
done

if [[ $all_envs == true && ${#invalid_args[@]} == 0 && ${#pyenvs_to_update[@]} == 0 ]]; then
  pyenvs_to_update=( "${pyenvs[@]}" )
fi

if [[ ${#invalid_args[@]} -gt 0 ]]; then
  __msg_error "Invalid environments entered: $(IFS=$' '; echo "${invalid_args[*]}")"
  pyenv-help pip-upgrade >&2
  exit 1
fi

__msg_info "Pyenvs to update: $(IFS=$' '; echo "${pyenvs_to_update[*]}")"
for pyenv_to_update in "${pyenvs_to_update[@]}"; do
  __msg_info "Updating packages of '${pyenv_to_update}'..."
  export PYENV_VERSION=${pyenv_to_update}

  # So as in conda environments pip is also available we check if this is a
  # conda environment at first.
  if conda >/dev/null 2>&1; then
      __msg_info "Updating conda environment: ${pyenv_to_update}..."
      conda update --all
      # in conda there could be packages installed with pip
      pip_upgrade_packages
  elif pip >/dev/null 2>&1; then
       __msg_info "Updating pip environment: ${pyenv_to_update}..."
       pip_upgrade_packages
  else
      __msg_error "Neither conda nor pip environment is detected. Skipping it!"
  fi
done
